<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 Portland School Board Election Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-fullscreen@1.0.1/dist/leaflet.fullscreen.css" />
    
    <!-- Chart.js for popup charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 350px;
            font-size: 14px;
        }
        
        .control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .layer-control {
            margin-bottom: 10px;
        }
        
        .layer-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .layer-control select {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .opacity-control, .range-control {
            margin: 10px 0;
        }
        
        .opacity-control input, .range-control input {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 5px;
        }
        
        .range-inputs input {
            padding: 3px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .legend {
            margin-top: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .popup-chart {
            width: 280px !important;
            height: 180px !important;
            max-width: 280px !important;
            max-height: 180px !important;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .zone-filter {
            margin-bottom: 15px;
        }
        
        .zone-filter input {
            margin-right: 5px;
        }
        
        .school-overlays, .advanced-features {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .school-overlays h4, .advanced-features h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }
        
        .overlay-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .overlay-item input {
            margin-right: 8px;
        }
        
        .overlay-item label {
            font-size: 12px;
            color: #555;
            cursor: pointer;
            margin: 0;
        }
        
        .leaflet-popup-content {
            max-width: 320px !important;
            max-height: 500px !important;
            overflow-y: auto;
        }
        
        .precinct-hover {
            background: #f0f8ff;
            padding: 8px;
            border-radius: 4px;
            border-left: 4px solid #1f77b4;
        }
        
        .stats-summary {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .feature-button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 12px;
        }
        
        .feature-button:hover {
            background: #e9ecef;
        }
        
        .feature-button.active {
            background: #007bff;
            color: white;
        }
        
        .range-display {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
        
        .dataset-control {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <h3>Loading Election Data...</h3>
        <p>Please wait while we load the precinct and school data.</p>
    </div>
    
    <div id="map"></div>
    
    <div class="control-panel">
        <h3>Map Controls</h3>
        
        <div class="dataset-control">
            <label for="dataset-select">Election Dataset:</label>
            <select id="dataset-select">
                <option value="zone1">Zone 1 Election Results</option>
                <option value="zone5">Zone 5 Election Results</option>
                <option value="voter_reg">Voter Registration Only</option>
            </select>
        </div>
        
        <div class="zone-filter">
            <label>
                <input type="checkbox" id="zone1-only" checked> Show Zone 1 Only
            </label>
        </div>
        
        <div class="layer-control">
            <label for="layer-select">Display Layer:</label>
            <select id="layer-select">
                <!-- Options will be populated based on selected dataset -->
            </select>
        </div>
        
        <div class="opacity-control">
            <label for="opacity-slider">Layer Opacity:</label>
            <input type="range" id="opacity-slider" min="0.1" max="1" step="0.1" value="0.7">
            <span id="opacity-value">70%</span>
        </div>
        
        <div class="range-control" id="range-control" style="display: none;">
            <label>Color Range (adjust for better contrast):</label>
            <div class="range-inputs">
                <input type="number" id="range-min" placeholder="Min" step="0.1">
                <input type="number" id="range-max" placeholder="Max" step="0.1">
            </div>
            <div class="range-display" id="range-display"></div>
            <button type="button" onclick="resetRange()" style="width: 100%; margin-top: 5px; padding: 4px; border: 1px solid #ddd; border-radius: 3px; background: #f8f9fa; font-size: 11px;">Reset to Auto</button>
        </div>
        
        <div class="layer-control">
            <label for="basemap-select">Base Map:</label>
            <select id="basemap-select">
                <option value="streets">Streets</option>
                <option value="satellite">Satellite</option>
                <option value="topo">Topographic</option>
            </select>
        </div>
        
        <div class="advanced-features">
            <h4>Advanced Features</h4>
            <button class="feature-button" id="heatmap-btn" onclick="toggleHeatmap()">üî• Vote Heatmap</button>
            <button class="feature-button" id="clustering-btn" onclick="toggleClustering()">üìç Cluster Schools</button>
            <button class="feature-button" id="drawing-btn" onclick="toggleDrawing()">‚úèÔ∏è Drawing Tools</button>
            <button class="feature-button" onclick="exportMap()">üìÑ Export View</button>
        </div>
        
        <div class="school-overlays">
            <h4>School Overlays</h4>
            <div class="overlay-item">
                <input type="checkbox" id="show-high-schools" />
                <label for="show-high-schools">High Schools</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-middle-schools" />
                <label for="show-middle-schools">Middle Schools</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-elementary-schools" />
                <label for="show-elementary-schools">Elementary Schools</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-high-boundaries" />
                <label for="show-high-boundaries">High School Boundaries</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-middle-boundaries" />
                <label for="show-middle-boundaries">Middle School Boundaries</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-elementary-boundaries" />
                <label for="show-elementary-boundaries">Elementary Boundaries</label>
            </div>
            <div class="overlay-item">
                <input type="checkbox" id="show-district-boundary" />
                <label for="show-district-boundary">District Boundary</label>
            </div>
        </div>
        
        <div id="legend" class="legend"></div>
        
        <div class="stats-summary" id="stats-summary"></div>
    </div>
    
    <div class="info-panel">
        <h3 id="map-title">2025 School Board Zone 1</h3>
        <p><strong>Click a precinct</strong> to see detailed results.</p>
        <div id="precinct-info">
            <p>Hover over precincts to see basic information, or click for detailed candidate results.</p>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet plugins -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-fullscreen@1.0.1/dist/Leaflet.fullscreen.min.js"></script>
    
    <script>
        // Initialize the map with fullscreen control
        const map = L.map('map', {
            fullscreenControl: true,
            fullscreenControlOptions: {
                position: 'topleft'
            }
        }).setView([45.5152, -122.6784], 11);
        
        // Base map layers
        const baseMaps = {
            streets: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap contributors'
            })
        };
        
        // Default base map
        baseMaps.streets.addTo(map);
        
        // Global variables
        let electionData = null;
        let currentLayer = null;
        let currentField = 'political_lean';
        let currentDataset = 'zone1';
        let showZone1Only = true;
        let heatmapLayer = null;
        let drawControl = null;
        let drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // School overlay layers
        let schoolLayers = {};
        let schoolClusters = {};
        let clusteringEnabled = false;
        
        // Dynamic range tracking
        let customRange = null;
        let actualDataRanges = {};
        
        // Dataset configurations
        const datasets = {
            zone1: {
                file: '../data/geospatial/2025_election_zone1_total_votes_processed.geojson',
                title: '2025 School Board Zone 1',
                layers: [
                    'political_lean', 'competitiveness', 'leading_candidate', 'turnout_rate',
                    'vote_margin', 'cnt_total_votes', 'cnt_cavagnolo', 'cnt_splitt', 'cnt_leof',
                    'dem_advantage', 'pct_cavagnolo', 'pct_splitt', 'pct_leof',
                    'pct_dem', 'pct_rep', 'pct_nav'
                ]
            },
            zone5: {
                file: '../data/geospatial/2025_election_zone5_total_votes_processed.geojson',
                title: '2025 School Board Zone 5',
                layers: [
                    'political_lean', 'competitiveness', 'leading_candidate', 'turnout_rate',
                    'vote_margin', 'cnt_total_votes', 'cnt_sanchez_bautista', 'cnt_la_forte',
                    'dem_advantage', 'pct_sanchez_bautista', 'pct_la_forte',
                    'pct_dem', 'pct_rep', 'pct_nav'
                ]
            },
            voter_reg: {
                file: '../data/geospatial/multnomah_precinct_voter_totals_processed.geojson',
                title: 'Voter Registration Data',
                layers: [
                    'political_lean', 'dem_advantage', 'major_party_pct',
                    'pct_dem', 'pct_rep', 'pct_nav', 'total_voters'
                ]
            }
        };
        
        // Color schemes for different data types
        const colorSchemes = {
            political_lean: {
                'Strong Dem': '#1f77b4',
                'Lean Dem': '#aec7e8', 
                'Competitive': '#ffbb78',
                'Lean Rep': '#ff7f0e',
                'Strong Rep': '#d62728'
            },
            competitiveness: {
                'Safe': '#2ca02c',
                'Likely': '#98df8a',
                'Competitive': '#ff7f0e',
                'Tossup': '#d62728'
            },
            leading_candidate: {
                'Cavagnolo': '#1f77b4',
                'Splitt': '#ff7f0e', 
                'Leof': '#2ca02c',
                'Sanchez_Bautista': '#1f77b4',
                'La_Forte': '#ff7f0e',
                'Tie': '#7f7f7f'
            }
        };
        
        // Calculate actual data ranges from loaded data
        function calculateDataRanges() {
            if (!electionData) return;
            
            const zone1Features = electionData.features.filter(f => f.properties.in_zone1 || !showZone1Only);
            
            // Calculate min/max for each numeric field
            const numericFields = [
                'cnt_total_votes', 'cnt_cavagnolo', 'cnt_splitt', 'cnt_leof',
                'cnt_sanchez_bautista', 'cnt_la_forte', 'total_voters',
                'pct_cavagnolo', 'pct_splitt', 'pct_leof', 'pct_sanchez_bautista', 'pct_la_forte',
                'turnout_rate', 'vote_margin', 'dem_advantage', 'major_party_pct',
                'pct_dem', 'pct_rep', 'pct_nav'
            ];
            
            numericFields.forEach(field => {
                const values = zone1Features
                    .map(f => f.properties[field])
                    .filter(v => v !== null && v !== undefined && !isNaN(v));
                
                if (values.length > 0) {
                    // Convert percentages to 0-100 scale for display
                    if (field.includes('pct_') || field === 'turnout_rate' || field === 'major_party_pct') {
                        actualDataRanges[field] = {
                            min: Math.min(...values) * 100,
                            max: Math.max(...values) * 100
                        };
                    } else {
                        actualDataRanges[field] = {
                            min: Math.min(...values),
                            max: Math.max(...values)
                        };
                    }
                }
            });
            
            console.log('Calculated actual ranges:', actualDataRanges);
        }
        
        // Update layer options based on selected dataset
        function updateLayerOptions() {
            const layerSelect = document.getElementById('layer-select');
            layerSelect.innerHTML = '';
            
            const config = datasets[currentDataset];
            if (!config) return;
            
            const layerNames = {
                'political_lean': 'Political Lean',
                'competitiveness': 'Competitiveness',
                'leading_candidate': 'Leading Candidate',
                'turnout_rate': 'Turnout Rate',
                'vote_margin': 'Victory Margin',
                'cnt_total_votes': 'Total Votes',
                'cnt_cavagnolo': 'Cavagnolo Vote Count',
                'cnt_splitt': 'Splitt Vote Count',
                'cnt_leof': 'Leof Vote Count',
                'cnt_sanchez_bautista': 'Sanchez Bautista Vote Count',
                'cnt_la_forte': 'La Forte Vote Count',
                'dem_advantage': 'Democratic Advantage',
                'major_party_pct': 'Major Party Registration %',
                'pct_cavagnolo': 'Cavagnolo %',
                'pct_splitt': 'Splitt %',
                'pct_leof': 'Leof %',
                'pct_sanchez_bautista': 'Sanchez Bautista %',
                'pct_la_forte': 'La Forte %',
                'pct_dem': 'Democratic Registration %',
                'pct_rep': 'Republican Registration %',
                'pct_nav': 'Non-Affiliated %',
                'total_voters': 'Total Registered Voters'
            };
            
            config.layers.forEach(layer => {
                const option = document.createElement('option');
                option.value = layer;
                option.textContent = layerNames[layer] || layer;
                layerSelect.appendChild(option);
            });
            
            // Set default field
            currentField = config.layers[0];
            layerSelect.value = currentField;
        }
        
        // Load election data based on selected dataset
        async function loadElectionData() {
            try {
                const config = datasets[currentDataset];
                if (!config) throw new Error(`Unknown dataset: ${currentDataset}`);
                
                document.getElementById('loading').style.display = 'block';
                document.getElementById('map-title').textContent = config.title;
                
                const response = await fetch(config.file);
                electionData = await response.json();
                
                console.log('Loaded GeoJSON with', electionData.features.length, 'features for', currentDataset);
                
                // Calculate actual data ranges
                calculateDataRanges();
                
                // Update layer options
                updateLayerOptions();
                
                updateMap();
                updateStatsDisplay();
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error loading election data:', error);
                document.getElementById('loading').innerHTML = '<h3>Error Loading Data</h3><p>Could not load election data. Please check the console for details.</p>';
            }
        }
        
        // Load school overlay data
        async function loadSchoolData() {
            const schoolFiles = {
                'high-schools': '../data/geospatial/pps_high_school_locations.geojson',
                'middle-schools': '../data/geospatial/pps_middle_school_locations.geojson',
                'elementary-schools': '../data/geospatial/pps_elementary_school_locations.geojson',
                'high-boundaries': '../data/geospatial/pps_high_school_boundaries.geojson',
                'middle-boundaries': '../data/geospatial/pps_middle_school_boundaries.geojson',
                'elementary-boundaries': '../data/geospatial/pps_elementary_school_boundaries.geojson',
                'district-boundary': '../data/geospatial/pps_district_boundary.geojson'
            };
            
            for (const [key, url] of Object.entries(schoolFiles)) {
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    let layer;
                    if (key.includes('boundaries') || key.includes('boundary')) {
                        // Boundary layers as polygons
                        layer = L.geoJSON(data, {
                            style: {
                                fillColor: key === 'district-boundary' ? '#ff7f0e' : 
                                          key.includes('high') ? '#d62728' :
                                          key.includes('middle') ? '#2ca02c' : '#1f77b4',
                                weight: key === 'district-boundary' ? 3 : 2,
                                opacity: 0.8,
                                color: key === 'district-boundary' ? '#ff7f0e' : 
                                       key.includes('high') ? '#d62728' :
                                       key.includes('middle') ? '#2ca02c' : '#1f77b4',
                                fillOpacity: 0.1
                            },
                            onEachFeature: function(feature, layer) {
                                const props = feature.properties;
                                layer.bindPopup(`
                                    <div style="max-width: 200px;">
                                        <h4>${props.School_Name || props.SCHOOL_NAM || 'School Boundary'}</h4>
                                        <p><strong>Type:</strong> ${key.replace('-', ' ')}</p>
                                        ${props.School_GradeGroup ? `<p><strong>Grades:</strong> ${props.School_GradeGroup}</p>` : ''}
                                    </div>
                                `);
                            }
                        });
                        schoolLayers[key] = layer;
                    } else {
                        // Point layers for school locations - create both regular and clustered versions
                        const markers = [];
                        
                        layer = L.geoJSON(data, {
                            pointToLayer: function(feature, latlng) {
                                const marker = L.circleMarker(latlng, {
                                    radius: 6,
                                    fillColor: key.includes('high') ? '#d62728' :
                                              key.includes('middle') ? '#2ca02c' : '#1f77b4',
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                });
                                markers.push(marker);
                                return marker;
                            },
                            onEachFeature: function(feature, layer) {
                                const props = feature.properties;
                                layer.bindPopup(`
                                    <div style="max-width: 250px;">
                                        <h4>${props.School_Name || props.simple_nm}</h4>
                                        <p><strong>Address:</strong> ${props.SiteAddress || 'N/A'}</p>
                                        <p><strong>Type:</strong> ${props.School_Type || props.School_GradeGroup || 'School'}</p>
                                        <p><strong>Status:</strong> ${props.Status || 'Active'}</p>
                                        ${props.HS_Cluster ? `<p><strong>HS Cluster:</strong> ${props.HS_Cluster}</p>` : ''}
                                    </div>
                                `);
                            }
                        });
                        
                        // Create clustered version
                        const cluster = L.markerClusterGroup({
                            iconCreateFunction: function(cluster) {
                                const count = cluster.getChildCount();
                                const color = key.includes('high') ? '#d62728' :
                                             key.includes('middle') ? '#2ca02c' : '#1f77b4';
                                return L.divIcon({
                                    html: `<div style="background: ${color}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${count}</div>`,
                                    className: 'custom-cluster-icon',
                                    iconSize: [30, 30]
                                });
                            }
                        });
                        
                        data.features.forEach(feature => {
                            const marker = L.circleMarker([feature.geometry.coordinates[1], feature.geometry.coordinates[0]], {
                                radius: 6,
                                fillColor: key.includes('high') ? '#d62728' :
                                          key.includes('middle') ? '#2ca02c' : '#1f77b4',
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                            
                            const props = feature.properties;
                            marker.bindPopup(`
                                <div style="max-width: 250px;">
                                    <h4>${props.School_Name || props.simple_nm}</h4>
                                    <p><strong>Address:</strong> ${props.SiteAddress || 'N/A'}</p>
                                    <p><strong>Type:</strong> ${props.School_Type || props.School_GradeGroup || 'School'}</p>
                                    <p><strong>Status:</strong> ${props.Status || 'Active'}</p>
                                    ${props.HS_Cluster ? `<p><strong>HS Cluster:</strong> ${props.HS_Cluster}</p>` : ''}
                                </div>
                            `);
                            
                            cluster.addLayer(marker);
                        });
                        
                        schoolLayers[key] = layer;
                        schoolClusters[key] = cluster;
                    }
                    
                } catch (error) {
                    console.warn(`Could not load ${key}:`, error);
                }
            }
        }
        
        // Get current range (custom or auto)
        function getCurrentRange(field) {
            if (customRange && customRange.field === field) {
                return customRange;
            }
            return actualDataRanges[field] || { min: 0, max: 100 };
        }
        
        // Get color for a feature based on current field with FIXED scaling (darker = more)
        function getFeatureColor(properties) {
            const value = properties[currentField];
            
            if (colorSchemes[currentField]) {
                return colorSchemes[currentField][value] || '#808080';
            }
            
            // For numeric fields, use data-driven gradients with CORRECTED scaling
            if (typeof value === 'number') {
                const range = getCurrentRange(currentField);
                
                if (range) {
                    // Convert value to display scale if needed
                    let displayValue = value;
                    if (currentField.includes('pct_') || currentField === 'turnout_rate' || currentField === 'major_party_pct') {
                        displayValue = value * 100;
                    }
                    
                    const normalized = Math.max(0, Math.min(1, (displayValue - range.min) / (range.max - range.min)));
                    
                    if (currentField.includes('pct_') || currentField === 'turnout_rate' || currentField === 'major_party_pct') {
                        // FIXED: Use blue-to-red gradient for percentages, darker = higher values
                        const hue = 240 - (normalized * 120); // Blue to red
                        const lightness = 90 - (normalized * 50); // FIXED: darker = higher values
                        return `hsl(${hue}, 70%, ${lightness}%)`;
                    } else if (currentField.includes('cnt_') || currentField === 'total_voters') {
                        // FIXED: Use blue gradient for counts, darker = higher values
                        const lightness = 90 - (normalized * 50); // FIXED: darker = higher values
                        return `hsl(220, 70%, ${lightness}%)`;
                    } else if (currentField === 'dem_advantage') {
                        // Diverging color scheme for dem advantage
                        const intensity = Math.abs(displayValue) / Math.max(Math.abs(range.min), Math.abs(range.max));
                        const hue = displayValue >= 0 ? 240 : 0; // Blue for positive, red for negative
                        const lightness = 70 - (intensity * 30); // FIXED: darker = more intense
                        return `hsl(${hue}, 70%, ${lightness}%)`;
                    } else {
                        // Default gradient - darker = higher values
                        const lightness = 90 - (normalized * 50); // FIXED: darker = higher values
                        return `hsl(220, 70%, ${lightness}%)`;
                    }
                } else {
                    // Fallback for fields without defined ranges
                    const intensity = Math.min(Math.abs(value) / 100, 1);
                    const lightness = 90 - (intensity * 40); // FIXED: darker = higher values
                    return `hsl(220, 70%, ${lightness}%)`;
                }
            }
            
            return '#808080'; // Default gray
        }
        
        // Style function for GeoJSON layer
        function styleFeature(feature) {
            const props = feature.properties;
            
            // Filter for Zone 1 if enabled
            if (showZone1Only && !props.in_zone1) {
                return {
                    fillColor: 'transparent',
                    color: 'transparent',
                    weight: 0,
                    fillOpacity: 0
                };
            }
            
            return {
                fillColor: getFeatureColor(props),
                weight: 1,
                opacity: 0.8,
                color: '#666',
                fillOpacity: parseFloat(document.getElementById('opacity-slider').value)
            };
        }
        
        // Create popup content with candidate results chart (fixed sizing)
        function createPopupContent(properties) {
            // Dynamic candidate selection based on dataset
            let candidates = [];
            if (currentDataset === 'zone1') {
                candidates = [
                    { name: 'Cavagnolo', count: properties.cnt_cavagnolo, pct: properties.pct_cavagnolo * 100 },
                    { name: 'Splitt', count: properties.cnt_splitt, pct: properties.pct_splitt * 100 },
                    { name: 'Leof', count: properties.cnt_leof, pct: properties.pct_leof * 100 }
                ].filter(c => c.count > 0);
            } else if (currentDataset === 'zone5') {
                candidates = [
                    { name: 'Sanchez Bautista', count: properties.cnt_sanchez_bautista, pct: properties.pct_sanchez_bautista * 100 },
                    { name: 'La Forte', count: properties.cnt_la_forte, pct: properties.pct_la_forte * 100 }
                ].filter(c => c.count > 0);
            }
            
            const popupId = 'popup-' + Math.random().toString(36).substr(2, 9);
            
            let content = `
                <div style="width: 300px; max-width: 300px;">
                    <h3>Precinct ${properties.precinct}</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <strong>Results:</strong><br>
                            <small>Total Votes: ${properties.cnt_total_votes || 'N/A'}</small><br>
                            <small>Turnout: ${properties.turnout_rate ? (properties.turnout_rate * 100).toFixed(1) + '%' : 'N/A'}</small><br>
                            <small>Leading: ${properties.leading_candidate || 'N/A'}</small>
                        </div>
                        <div>
                            <strong>Analysis:</strong><br>
                            <small>Political Lean: ${properties.political_lean || 'N/A'}</small><br>
                            <small>Competitiveness: ${properties.competitiveness || 'N/A'}</small><br>
                            <small>Margin: ${properties.vote_margin ? properties.vote_margin.toFixed(0) + ' votes' : 'N/A'}</small>
                        </div>
                    </div>
            `;
            
            if (candidates.length > 0) {
                content += `
                    <div>
                        <strong>Candidate Results:</strong>
                        <div style="width: 280px; height: 180px; margin-top: 10px;">
                            <canvas id="${popupId}" class="popup-chart"></canvas>
                        </div>
                    </div>
                `;
            }
            
            content += '</div>';
            
            // Set up chart after popup opens with fixed dimensions
            setTimeout(() => {
                const canvas = document.getElementById(popupId);
                if (canvas && candidates.length > 0) {
                    canvas.width = 280;
                    canvas.height = 180;
                    
                    new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: candidates.map(c => c.name),
                            datasets: [{
                                label: 'Votes',
                                data: candidates.map(c => c.count),
                                backgroundColor: ['#1f77b4', '#ff7f0e', '#2ca02c'],
                                borderColor: ['#1f77b4', '#ff7f0e', '#2ca02c'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: false,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            const candidate = candidates[context.dataIndex];
                                            return `${candidate.pct.toFixed(1)}%`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: { display: true, text: 'Votes' }
                                }
                            }
                        }
                    });
                }
            }, 100);
            
            return content;
        }
        
        // Update the map with current settings
        function updateMap() {
            if (!electionData) return;
            
            // Remove existing layer
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }
            
            // Create new layer
            currentLayer = L.geoJSON(electionData, {
                style: styleFeature,
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    
                    // Skip if filtering Zone 1 and not in zone
                    if (showZone1Only && !props.in_zone1) return;
                    
                    // Hover effects with better info display
                    layer.on('mouseover', function() {
                        const info = document.getElementById('precinct-info');
                        const value = props[currentField];
                        const displayValue = typeof value === 'number' ? 
                            (currentField.includes('pct_') || currentField === 'turnout_rate' || currentField === 'major_party_pct' ? 
                                (value * 100).toFixed(1) + '%' : 
                                value.toLocaleString()) :
                            (value || 'N/A');
                            
                        info.innerHTML = `
                            <div class="precinct-hover">
                                <h4>Precinct ${props.precinct}</h4>
                                <p><strong>${currentField.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</strong> ${displayValue}</p>
                                <p><small>Total Votes: ${props.cnt_total_votes || 'N/A'}</small></p>
                                <p><small>Leading: ${props.leading_candidate || 'N/A'}</small></p>
                                <p><small><em>Click for detailed results</em></small></p>
                            </div>
                        `;
                        
                        layer.setStyle({
                            weight: 3,
                            color: '#fff',
                            fillOpacity: 0.9
                        });
                    });
                    
                    layer.on('mouseout', function() {
                        const info = document.getElementById('precinct-info');
                        info.innerHTML = '<p>Hover over precincts to see basic information, or click for detailed candidate results.</p>';
                        currentLayer.resetStyle(layer);
                    });
                    
                    // Click for detailed popup
                    layer.on('click', function() {
                        layer.bindPopup(createPopupContent(props), {
                            maxWidth: 320,
                            maxHeight: 500,
                            className: 'election-popup'
                        }).openPopup();
                    });
                }
            }).addTo(map);
            
            updateLegend();
            updateRangeControls();
        }
        
        // Update range controls
        function updateRangeControls() {
            const rangeControl = document.getElementById('range-control');
            const isNumeric = !colorSchemes[currentField];
            
            if (isNumeric) {
                rangeControl.style.display = 'block';
                const range = getCurrentRange(currentField);
                
                document.getElementById('range-min').value = range.min.toFixed(1);
                document.getElementById('range-max').value = range.max.toFixed(1);
                document.getElementById('range-display').textContent = 
                    `Current: ${range.min.toFixed(1)} - ${range.max.toFixed(1)}`;
            } else {
                rangeControl.style.display = 'none';
            }
        }
        
        // Reset range to auto-calculated
        function resetRange() {
            customRange = null;
            updateMap();
        }
        
        // Update the legend with better granularity
        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '<h4>' + currentField.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) + '</h4>';
            
            if (colorSchemes[currentField]) {
                Object.entries(colorSchemes[currentField]).forEach(([value, color]) => {
                    legend.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${color}"></div>
                            <span>${value}</span>
                        </div>
                    `;
                });
            } else {
                const range = getCurrentRange(currentField);
                if (range) {
                    const steps = 5;
                    legend.innerHTML += '<div style="font-size: 11px;">';
                    for (let i = 0; i < steps; i++) {
                        const value = range.min + (i / (steps - 1)) * (range.max - range.min);
                        const color = getFeatureColor({[currentField]: currentField.includes('pct_') || currentField === 'turnout_rate' || currentField === 'major_party_pct' ? value/100 : value});
                        const displayValue = currentField.includes('pct_') || currentField === 'turnout_rate' || currentField === 'major_party_pct' ? 
                            value.toFixed(1) + '%' : 
                            Math.round(value).toLocaleString();
                        legend.innerHTML += `
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: ${color}"></div>
                                <span>${displayValue}</span>
                            </div>
                        `;
                    }
                    legend.innerHTML += '</div>';
                } else {
                    legend.innerHTML += '<p>Darker colors indicate higher values</p>';
                }
            }
        }
        
        // Update stats display
        function updateStatsDisplay() {
            if (!electionData) return;
            
            const filteredFeatures = electionData.features.filter(f => !showZone1Only || f.properties.in_zone1);
            const totalVotes = filteredFeatures.reduce((sum, f) => sum + (f.properties.cnt_total_votes || 0), 0);
            const avgTurnout = filteredFeatures.reduce((sum, f) => sum + (f.properties.turnout_rate || 0), 0) / filteredFeatures.length;
            
            let summary = `<strong>Summary:</strong><br>`;
            summary += `<small>Precincts: ${filteredFeatures.length}</small><br>`;
            
            if (totalVotes > 0) {
                summary += `<small>Total Votes: ${totalVotes.toLocaleString()}</small><br>`;
                summary += `<small>Avg Turnout: ${(avgTurnout * 100).toFixed(1)}%</small><br>`;
                
                if (currentDataset === 'zone1') {
                    const cavagnoloVotes = filteredFeatures.reduce((sum, f) => sum + (f.properties.cnt_cavagnolo || 0), 0);
                    const splittVotes = filteredFeatures.reduce((sum, f) => sum + (f.properties.cnt_splitt || 0), 0);
                    summary += `<small>Cavagnolo: ${cavagnoloVotes.toLocaleString()} (${(cavagnoloVotes/totalVotes*100).toFixed(1)}%)</small><br>`;
                    summary += `<small>Splitt: ${splittVotes.toLocaleString()} (${(splittVotes/totalVotes*100).toFixed(1)}%)</small>`;
                } else if (currentDataset === 'zone5') {
                    const sanchezVotes = filteredFeatures.reduce((sum, f) => sum + (f.properties.cnt_sanchez_bautista || 0), 0);
                    const laForteVotes = filteredFeatures.reduce((sum, f) => sum + (f.properties.cnt_la_forte || 0), 0);
                    summary += `<small>Sanchez Bautista: ${sanchezVotes.toLocaleString()} (${(sanchezVotes/totalVotes*100).toFixed(1)}%)</small><br>`;
                    summary += `<small>La Forte: ${laForteVotes.toLocaleString()} (${(laForteVotes/totalVotes*100).toFixed(1)}%)</small>`;
                }
            } else {
                summary += `<small>No election data available</small>`;
            }
            
            document.getElementById('stats-summary').innerHTML = summary;
        }
        
        // Toggle heatmap with FIXED coordinate extraction
        function toggleHeatmap() {
            const btn = document.getElementById('heatmap-btn');
            
            if (heatmapLayer) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
                btn.classList.remove('active');
            } else {
                if (electionData) {
                    const heatData = [];
                    
                    electionData.features
                        .filter(f => (!showZone1Only || f.properties.in_zone1) && f.properties.cnt_total_votes)
                        .forEach(f => {
                            if (f.geometry && f.geometry.coordinates && f.geometry.coordinates[0]) {
                                // FIXED: Handle different geometry types properly
                                let coords;
                                if (f.geometry.type === 'Polygon') {
                                    // For polygons, get the centroid of the first ring
                                    const ring = f.geometry.coordinates[0];
                                    if (ring && ring.length > 0) {
                                        // Calculate centroid
                                        let totalLat = 0, totalLng = 0;
                                        ring.forEach(point => {
                                            if (point && point.length >= 2) {
                                                totalLng += point[0];
                                                totalLat += point[1];
                                            }
                                        });
                                        coords = [totalLat / ring.length, totalLng / ring.length];
                                    }
                                } else if (f.geometry.type === 'Point') {
                                    coords = [f.geometry.coordinates[1], f.geometry.coordinates[0]];
                                }
                                
                                if (coords && coords[0] && coords[1] && !isNaN(coords[0]) && !isNaN(coords[1])) {
                                    heatData.push([coords[0], coords[1], f.properties.cnt_total_votes / 100]);
                                }
                            }
                        });
                    
                    console.log('Heatmap data points:', heatData.length);
                    
                    if (heatData.length > 0) {
                        heatmapLayer = L.heatLayer(heatData, {
                            radius: 25,
                            blur: 15,
                            maxZoom: 17
                        }).addTo(map);
                        
                        btn.classList.add('active');
                    } else {
                        console.warn('No valid coordinates found for heatmap');
                    }
                }
            }
        }
        
        // Toggle clustering for schools
        function toggleClustering() {
            const btn = document.getElementById('clustering-btn');
            clusteringEnabled = !clusteringEnabled;
            
            if (clusteringEnabled) {
                btn.classList.add('active');
                btn.textContent = 'üìç Clustering ON';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üìç Cluster Schools';
            }
            
            // Update all visible school layers
            ['high-schools', 'middle-schools', 'elementary-schools'].forEach(layerId => {
                const checkbox = document.getElementById(`show-${layerId}`);
                if (checkbox.checked) {
                    toggleSchoolLayer(layerId, false); // Remove current
                    toggleSchoolLayer(layerId, true);  // Re-add with new clustering state
                }
            });
        }
        
        // Toggle drawing tools
        function toggleDrawing() {
            const btn = document.getElementById('drawing-btn');
            
            if (drawControl) {
                map.removeControl(drawControl);
                drawControl = null;
                btn.classList.remove('active');
                btn.textContent = '‚úèÔ∏è Drawing Tools';
            } else {
                drawControl = new L.Control.Draw({
                    edit: {
                        featureGroup: drawnItems
                    },
                    draw: {
                        polygon: true,
                        polyline: true,
                        rectangle: true,
                        circle: true,
                        marker: true,
                        circlemarker: false
                    }
                });
                
                map.addControl(drawControl);
                btn.classList.add('active');
                btn.textContent = '‚úèÔ∏è Drawing ON';
                
                // Handle drawn items
                map.on(L.Draw.Event.CREATED, function(e) {
                    drawnItems.addLayer(e.layer);
                });
            }
        }
        
        // Export map
        function exportMap() {
            // Simple implementation - could be enhanced with leaflet-image or similar
            const mapData = {
                center: map.getCenter(),
                zoom: map.getZoom(),
                layer: currentField,
                dataset: currentDataset,
                zone1Only: showZone1Only,
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(mapData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `election_map_${currentDataset}_${currentField}_${new Date().toISOString().slice(0,10)}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        // Toggle school overlay layers
        function toggleSchoolLayer(layerId, show) {
            const isPointLayer = !layerId.includes('boundaries') && layerId !== 'district-boundary';
            let layer;
            
            if (isPointLayer && clusteringEnabled) {
                layer = schoolClusters[layerId];
            } else {
                layer = schoolLayers[layerId];
            }
            
            if (!layer) return;
            
            if (show) {
                map.addLayer(layer);
            } else {
                map.removeLayer(layer);
            }
        }
        
        // Event listeners
        document.getElementById('dataset-select').addEventListener('change', function() {
            currentDataset = this.value;
            customRange = null; // Reset custom range when changing datasets
            loadElectionData();
        });
        
        document.getElementById('layer-select').addEventListener('change', function() {
            currentField = this.value;
            customRange = null; // Reset custom range when changing layers
            updateMap();
        });
        
        document.getElementById('opacity-slider').addEventListener('input', function() {
            const value = Math.round(this.value * 100);
            document.getElementById('opacity-value').textContent = value + '%';
            updateMap();
        });
        
        document.getElementById('zone1-only').addEventListener('change', function() {
            showZone1Only = this.checked;
            calculateDataRanges(); // Recalculate ranges for filtered data
            updateMap();
            updateStatsDisplay();
        });
        
        document.getElementById('basemap-select').addEventListener('change', function() {
            Object.values(baseMaps).forEach(layer => map.removeLayer(layer));
            baseMaps[this.value].addTo(map);
        });
        
        // Range control event listeners
        document.getElementById('range-min').addEventListener('change', function() {
            const min = parseFloat(this.value);
            const max = parseFloat(document.getElementById('range-max').value);
            
            if (!isNaN(min) && !isNaN(max) && min < max) {
                customRange = { field: currentField, min: min, max: max };
                updateMap();
            }
        });
        
        document.getElementById('range-max').addEventListener('change', function() {
            const min = parseFloat(document.getElementById('range-min').value);
            const max = parseFloat(this.value);
            
            if (!isNaN(min) && !isNaN(max) && min < max) {
                customRange = { field: currentField, min: min, max: max };
                updateMap();
            }
        });
        
        // School overlay event listeners
        ['high-schools', 'middle-schools', 'elementary-schools', 
         'high-boundaries', 'middle-boundaries', 'elementary-boundaries', 'district-boundary'].forEach(layerId => {
            document.getElementById(`show-${layerId}`).addEventListener('change', function() {
                toggleSchoolLayer(layerId, this.checked);
            });
        });
        
        // Load data when page loads
        Promise.all([loadElectionData(), loadSchoolData()]).then(() => {
            console.log('All data loaded successfully');
        }).catch(error => {
            console.error('Error loading data:', error);
        });
        
    </script>
</body>
</html> 